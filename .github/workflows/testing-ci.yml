name: CI (testing branch) â€” Backend Tests

on:
  push:
    branches: [ testing ]
    paths:
      - "backend/**"
      - ".github/workflows/**"
      - "terraform/**"
      - "k8s/**"

permissions:
  contents: read

jobs:
  test_backends:
    runs-on: ubuntu-latest
    timeout-minutes: 20

    # Ephemeral DBs + RabbitMQ for the test run
    services:
      product_db:
        image: postgres:15-alpine
        env:
          POSTGRES_USER: postgres
          POSTGRES_PASSWORD: postgres
          POSTGRES_DB: products
        ports: [ "5432:5432" ]
        options: >-
          --health-cmd "pg_isready -U postgres -d products"
          --health-interval 5s
          --health-timeout 5s
          --health-retries 20

      order_db:
        image: postgres:15-alpine
        env:
          POSTGRES_USER: postgres
          POSTGRES_PASSWORD: postgres
          POSTGRES_DB: orders
        ports: [ "5433:5432" ]
        options: >-
          --health-cmd "pg_isready -U postgres -d orders"
          --health-interval 5s
          --health-timeout 5s
          --health-retries 20

      customer_db:
        image: postgres:15-alpine
        env:
          POSTGRES_USER: postgres
          POSTGRES_PASSWORD: postgres
          POSTGRES_DB: customers
        ports: [ "5434:5432" ]
        options: >-
          --health-cmd "pg_isready -U postgres -d customers"
          --health-interval 5s
          --health-timeout 5s
          --health-retries 20

      rabbitmq:
        image: rabbitmq:3-management-alpine
        ports:
          - "5672:5672"
          - "15672:15672"
        options: >-
          --health-cmd "rabbitmq-diagnostics -q check_port_connectivity"
          --health-interval 5s
          --health-timeout 5s
          --health-retries 20

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Python 3.13
        uses: actions/setup-python@v5
        with:
          python-version: "3.13"

      - name: Cache pip
        uses: actions/cache@v4
        with:
          path: ~/.cache/pip
          key: pip-${{ runner.os }}-${{ hashFiles('backend/**/requirements.txt') }}
          restore-keys: |
            pip-${{ runner.os }}-

      - name: Install dependencies for all backends
        run: |
          pip install --upgrade pip
          for req in backend/*/requirements.txt; do
            echo "Installing $req"
            pip install -r "$req"
          done
          pip install pytest httpx

      # ---- Customer Service Tests ----
      - name: Test customer_service
        working-directory: backend/customer_service
        env:
          POSTGRES_HOST: localhost
          POSTGRES_PORT: "5434"
          POSTGRES_DB: customers
          POSTGRES_USER: postgres
          POSTGRES_PASSWORD: postgres
          # Safe dummy Azure vars so startup doesn't choke
          AZURE_STORAGE_ACCOUNT_NAME: testaccount
          AZURE_STORAGE_ACCOUNT_KEY: testkey
          AZURE_STORAGE_CONTAINER_NAME: images
          AZURE_SAS_TOKEN_EXPIRY_HOURS: "24"
          # Rabbit (if code references it)
          RABBITMQ_HOST: localhost
          RABBITMQ_PORT: "5672"
          RABBITMQ_USER: guest
          RABBITMQ_PASS: guest
        run: pytest -q

      # ---- Product Service Tests ----
      - name: Test product_service
        working-directory: backend/product_service
        env:
          POSTGRES_HOST: localhost
          POSTGRES_PORT: "5432"
          POSTGRES_DB: products
          POSTGRES_USER: postgres
          POSTGRES_PASSWORD: postgres
          AZURE_STORAGE_ACCOUNT_NAME: testaccount
          AZURE_STORAGE_ACCOUNT_KEY: testkey
          AZURE_STORAGE_CONTAINER_NAME: images
          AZURE_SAS_TOKEN_EXPIRY_HOURS: "24"
          RABBITMQ_HOST: localhost
          RABBITMQ_PORT: "5672"
          RABBITMQ_USER: guest
          RABBITMQ_PASS: guest
        run: pytest -q

      # ---- Order Service Tests ----
      - name: Test order_service
        working-directory: backend/order_service
        env:
          POSTGRES_HOST: localhost
          POSTGRES_PORT: "5433"
          POSTGRES_DB: orders
          POSTGRES_USER: postgres
          POSTGRES_PASSWORD: postgres
          # internal service URLs (if tests hit cross-service calls, keep them localhost or mock)
          CUSTOMER_SERVICE_URL: http://localhost:9999
          PRODUCT_SERVICE_URL: http://localhost:9998
          RABBITMQ_HOST: localhost
          RABBITMQ_PORT: "5672"
          RABBITMQ_USER: guest
          RABBITMQ_PASS: guest
        run: pytest -q

  # Job 2: Provision infrastructure with Terraform
  terraform_apply:
    environment: Testing
    runs-on: ubuntu-latest
    needs: test_backends   # only run if tests succeed

    permissions:
      id-token: write
      contents: read

    env:
      ARM_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
      ARM_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}
      ARM_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

    steps:
      # Checkout repo
      - name: Checkout repository
        uses: actions/checkout@v4

      # Setup Terraform CLI
      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.9.7   # match your local version

      # Azure login with OIDC
      - name: Azure Login (OIDC)
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      # Terraform Init
      - name: Terraform Init
        working-directory: terraform
        run: terraform init

      # Terraform Apply (auto-approve)
      - name: Terraform Apply
        working-directory: terraform
        run: terraform apply -auto-approve -var-file="environments/staging.tfvars"

      # Export outputs for later jobs (like storage account name & key, ACR server)
      - name: Capture Terraform Outputs
        id: tf_outputs
        working-directory: terraform
        run: |
          acr_server=$(terraform output -raw acr_login_server)
          echo "acr_server=$acr_server" >> $GITHUB_OUTPUT
          # Extract just the registry name before the first dot
          acr_name=$(echo $acr_server | cut -d. -f1)
          echo "acr_name=$acr_name" >> $GITHUB_OUTPUT
          echo "storage_account_name=$(terraform output -raw storage_account_name)" >> $GITHUB_OUTPUT
          echo "storage_account_key=$(terraform output -raw storage_account_key)" >> $GITHUB_OUTPUT
          echo "aks_rg=$(terraform output -raw resource_group_name)" >> $GITHUB_OUTPUT
          echo "aks_name=$(terraform output -raw aks_name)" >> $GITHUB_OUTPUT

    outputs:
      acr_server: ${{ steps.tf_outputs.outputs.acr_server }}
      acr_name: ${{ steps.tf_outputs.outputs.acr_name }}
      storage_account_name: ${{ steps.tf_outputs.outputs.storage_account_name }}
      storage_account_key: ${{ steps.tf_outputs.outputs.storage_account_key }}
      aks_rg: ${{ steps.tf_outputs.outputs.aks_rg }}
      aks_name: ${{ steps.tf_outputs.outputs.aks_name }}

  # Job 3: Build & Push Images to ACR
  build_and_push_images:
    environment: Testing
    runs-on: ubuntu-latest
    needs: terraform_apply   # only run if infra is ready

    env:
      IMAGE_TAG: ${{ github.sha }}
      ACR_SERVER: ${{ needs.terraform_apply.outputs.acr_server }}
      ACR_NAME: ${{ needs.terraform_apply.outputs.acr_name }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      # Login to Azure (OIDC)
      - name: Azure Login (OIDC)
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      # Login to ACR
      - name: ACR login
        run: az acr login --name "$ACR_NAME"

      # Build and push Product Service
      - name: Build & Push product_service
        run: |
          docker build -t $ACR_SERVER/product_service:$IMAGE_TAG ./backend/product_service
          docker tag  $ACR_SERVER/product_service:$IMAGE_TAG $ACR_SERVER/product_service:staging-latest
          docker push $ACR_SERVER/product_service:$IMAGE_TAG
          docker push $ACR_SERVER/product_service:staging-latest

      # Build and push Order Service
      - name: Build & Push order_service
        run: |
          docker build -t $ACR_SERVER/order_service:$IMAGE_TAG ./backend/order_service
          docker tag  $ACR_SERVER/order_service:$IMAGE_TAG $ACR_SERVER/order_service:staging-latest
          docker push $ACR_SERVER/order_service:$IMAGE_TAG
          docker push $ACR_SERVER/order_service:staging-latest

      # Build and push Customer Service
      - name: Build & Push customer_service
        run: |
          docker build -t $ACR_SERVER/customer_service:$IMAGE_TAG ./backend/customer_service
          docker tag  $ACR_SERVER/customer_service:$IMAGE_TAG $ACR_SERVER/customer_service:staging-latest
          docker push $ACR_SERVER/customer_service:$IMAGE_TAG
          docker push $ACR_SERVER/customer_service:staging-latest

      # Build and push Frontend
      - name: Build & Push frontend
        run: |
          docker build -t $ACR_SERVER/frontend:$IMAGE_TAG ./frontend
          docker tag  $ACR_SERVER/frontend:$IMAGE_TAG $ACR_SERVER/frontend:staging-latest
          docker push $ACR_SERVER/frontend:$IMAGE_TAG
          docker push $ACR_SERVER/frontend:staging-latest
